#pragma config(Sensor, S1,     Magnetic,       sensorAnalog)
#pragma config(Sensor, S2,     Ultrasonic,     sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "boilerplate.h"

#define RUN_MAIN 0

//RUN_MAIN defined in boilerplate.h
//Allows testing of low-level functions34
#if RUN_MAIN
task main () {
	nSyncedMotors = synchBC;
	dropBins();
	wait1Msec(1000);


}
#endif

//Returns number of ticks motorB should travel
int getSLEncoderCount (int distance) {
   return distance * ENCODER_COUNT_PER_CM;
}

// Encoder counts for degree rotation
int getSpinEncoderCount(int degrees) {
    int ret = ((degrees * ENCODER_COUNT_PER_ROTATION) / 360);
    return ret;
}

//Moves the motor forward for the specified number of centimeters
void driveStraight(int distance) {

    //Reset encoder count to zero so we just have to move to
    resetCount(motorB);

    //make motors b and c move at the same rate
    nSyncedTurnRatio = DRIVE_STRAIGHT;

    //Set target distance for motor b
    nMotorEncoderTarget[motorB] = getSLEncoderCount(distance);

    //Turn motor b on, give negative power for negative distance
    motor[motorB] = 30 * sgn(distance);

    //Do nothing until motor b has finished moving
    waitUntilStopped(motorB);

    //Wait 20 ms to let robot settle.
    wait1Msec(20);
}


//Spin the robot in place
//Works the same as drivestraight, but tells motor c to do the opposite of motor b
void turnRight(int degrees) {
    resetCount(motorB);
    nSyncedTurnRatio = SPIN_CLOCKWISE;
    nMotorEncoderTarget[motorB] = getSpinEncoderCount(degrees);
    motor[motorB] = 25 * sgn(degrees);
    waitUntilStopped(motorB);
    wait1Msec(20);
}

//Wrapper function for turning the current encoder count to zero.
//Just makes life easier
void resetCount (int motorNum) {
	nMotorEncoder[motorNum] = 0;
}

//Block current task until motor has stopped moving, then wait 1/2 s longer
void waitUntilStopped (int motorNum) {
    while (nMotorRunState[motorNum] == runStateRunning){wait1Msec(20);}
    wait1Msec(500);
}

//TODO tune how long turned on
void dropBins () {
	resetCount(motorA);

  //nMotorEncoderTarget[motorA] = 150;
  motor[motorA] = MOTOR_A_POWER;

  while (SensorValue(Ultrasonic) > 7) {
  	wait1Msec(25);
  	if (nMotorRunState[motorA] != runStateRunning){
  		return;
  	}

  	wait1Msec(25);
	}
 while (SensorValue(Ultrasonic) <= 9 || SensorValue(Ultrasonic) == 255) {
   wait1Msec(25);
   nxtDisplayTextLine(1, "U = %d", SensorValue(Ultrasonic));
   if (nMotorRunState[motorA] != runStateRunning){
  		return;
  	}
 }

 motor[motorA] = 0;
 resetCount(motorA);
 nMotorEncoderTarget[motorA] = 0;	//degrees

 nMotorEncoderTarget[motorA] = 125;
 motor[motorA] = MOTOR_A_POWER;
 waitUntilStopped(motorA);
 nxtDisplayTextLine(2, "Dropped");
 for (int i = 0; i < 3; i++) {
   playSound(soundBeepBeep);
 }

 wait1Msec(100);
}

// Find beacons
bool findBeacon () {
	bool foundBeacon = false;

    foundBeacon = driveUntilBeacon (MAX_DRIVE, DIST_TO_SEARCH);

    //If ALV couldn't find beacon, go back once more
    if (foundBeacon == false) {
    	foundBeacon = driveUntilBeacon (-MAX_DRIVE, - DIST_TO_SEARCH);

    	//Go forward to find beacon once more if still couldn't find it
    	if (foundBeacon == false) {
    		foundBeacon = driveUntilBeacon (MAX_DRIVE, DIST_TO_SEARCH);

    		//Go to back again
    		if (foundBeacon == false){
					foundBeacon = driveUntilBeacon (-MAX_DRIVE, -DIST_TO_SEARCH);
    		}
    	}
    }
    return foundBeacon;
}


//Drive until finding beacons
bool driveUntilBeacon (int maxDrive, int distToSearch) {
    bool foundBeacon = false;

    //Reset encoder count to zero
    resetCount (motorB);

    //Motor B and C move at the same time
    nSyncedTurnRatio = DRIVE_STRAIGHT;

    nMotorEncoderTarget[motorB] = getSLEncoderCount(maxDrive);
    nxtDisplayTextLine(1, "Enc = %d", nMotorEncoderTarget[motorB]);
		motor[motorB] = 30 * sgn(distToSearch);

    while (SensorValue(Magnetic) < MAGNET_VALUE) {
      nxtDisplayTextLine (2, "Value = %d", SensorValue(Magnetic));
      wait1Msec(25);
      if (nMotorRunState[motorB] != runStateRunning) {
      	nxtDisplayTextLine(3, "Bad");
      	break;
      }
    }

    motor[motorB] = 0;

    if (SensorValue(Magnetic) < MAGNET_VALUE) {
        foundBeacon = false;
    }
    else {
        foundBeacon = true;
        nxtDisplayTextLine(3, "foundBeacon");
        wait1Msec(1000);
    }


    nMotorEncoderTarget[motorB] = 0;
    waitUntilStopped (motorB);
    resetCount (motorB);
    //wait1Msec(10000);
    return foundBeacon;

}
